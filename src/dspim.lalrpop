use std::str::FromStr;
use crate::base_type_pim::{PIMBaseType, PIMType, PIMField, NamedBlock, Node};

grammar;

pub PIMBaseTypeRule: PIMBaseType = {
  "int8" => PIMBaseType::Int8,
  "int16" => PIMBaseType::Int16,
  "int32" => PIMBaseType::Int32,
  "int64" => PIMBaseType::Int64,
  "float" => PIMBaseType::Float,
  "double" => PIMBaseType::Double,
  "char" => PIMBaseType::Char,
};

pub PIMTypeRule: PIMType  = {
  <b: PIMBaseTypeRule> => PIMType::Basic(b),
  <b: PIMBaseTypeRule> "[" <n:Num> "]" => PIMType::Array(b, n)
};

pub TokenRule: &'input str = <s:r"[a-zA-Z][a-zA-Z0-9\_]*"> => s;

pub FieldRule: PIMField<'input> = <name: TokenRule> ":" <t: PIMTypeRule> => PIMField{varname:name, pim_type:t};

pub FieldListRule: Vec<PIMField<'input>> = {
  <f: FieldRule> ";" => Vec::from([f]),
  <l: FieldListRule> <f: FieldRule> ";" => {
    let mut _l = l.clone();
    _l.append(&mut vec! [f]);
    _l
  }
};

pub BlockRule: Vec<PIMField<'input>> = {
  "{" <l: FieldListRule> "}" => l
}

pub NamedBlockRule: NamedBlock<'input> = {
  <name: TokenRule> <b: BlockRule> => NamedBlock{name: name, fields: b}
}

pub NodeRule: Node<'input> = {
  "node" <block: NamedBlockRule> => Node(block)
}

Num: i32 = <s:r"[0-9]+"> => i32::from_str(s).unwrap();


pub Term: i32 = {
    <n:Num> => n,
    "(" <t:Term> ")" => t,
};

